[
["index.html", "R Module 2 Chapter 1 Welcome!", " R Module 2 Connor Gibbs1 16 Sep, 2020, 02:57 PM Chapter 1 Welcome! Hi, and welcome to the R Module 2 (AKA STAT 158) course at Colorado State University! This course is the second of three 1 credit courses intended to introduce the R programming language to those with little or no programming experience. Through these Modules (courses), we’ll explore how R can be used to do the following: Perform basic computations and logic, just like any other programming language Load, clean, analyze, and visualise data Run scripts Create reproducible reports so you can explain your work in a narrative form In addition, you’ll also be exposed to some aspects of the broader R community, including: R as free, open source software The RStudio free software Publicly available packages which extend the capability of R Events and community groups which advocate for the use of R and the support of R users More detail will be provided in the Course Topics laid out in the next chapter. 1.0.1 How To Navigate This Book To move quickly to different portions of the book, click on the appropriate chapter or section in the the table of contents on the left. The buttons at the top of the page allow you to show/hide the table of contents, search the book, change font settings, download a pdf or ebook copy of this book, or get hints on various sections of the book. The faint left and right arrows at the sides of each page (or bottom of the page if it’s narrow enough) allow you to step to the next/previous section. Here’s what they look like: Figure 1.1: Left and right navigation arrows Department of Statistics, Colorado State University, connor.gibbs@colostate.edu↩ "],
["associated-csu-course.html", "1.1 Associated CSU Course", " 1.1 Associated CSU Course This bookdown book is intended to accompany the associated course at Colorado State University, but the curriculum is free for anyone to access and use. If you’re reading the PDF or EPUB version of this book, you can find the “live” version at https://csu-r.github.io/Module2/, and all of the source files for this book can be found at https://github.com/CSU-R/Module2. If you’re not taking the CSU course, you will periodically encounter instructions and references which are not relevant to you. For example, we will make reference to the Canvas website, which only CSU students enrolled in the course have access to. "],
["AccessingData.html", "Chapter 2 Accessing Data", " Chapter 2 Accessing Data “Data is the new oil.” —Clive Humby, Chief Data Scientist, Starcount In this chapter, we’ll cover how to access data given in various forms and provided from various sources. "],
["rectangular-vs-non-rectangular-data.html", "2.1 Rectangular vs. Non-rectangular Data", " 2.1 Rectangular vs. Non-rectangular Data Data present themselves in many forms, but at a basic level, all data can be categorized into two structures: rectangular data and non-rectangular data. Intuitively, rectangular data are shaped like a rectangule where every value cooresponds to some row and column. Non-rectangular data, on the other hand, are not no neatly arranged in rows and columns. Instead, they are often a culmination of seperate data structures where there is some similarity among members of the same data strucuture. To motivate this idea, let’s consider a basic grocery list which consists of ten items: black beans, milk, pasta, cheese, bananas, peanut butter, bread, apples, tomato sauce, and mayonnaise. Notice, there is little organization to this list, and more involved shoppers may find this list inadequate or unhelpful. We may wish to group these items by sections in which we’re likely to find them. We may also want to include prices, so we know in-store whether the items are on sale. Let’s consider two distinct (but legitamate) ways to organize these data. To illustrate the idea of rectangular vs. non-rectangular data, we will consider how these data can be structured in both ways using R. You may not have seen some of these functions yet. No worries! The objective is not to understand how to utilize these functions but to comprehend the difference between rectangular and non-rectangular data. One may first consider grouping these items by section. For example, apples and bananas can be found in the produce section, whereas black beans and tomato sauce can be found in the canned goods. If we were to continue to group these items by section, we may arrive at a data set which looks something like this: groc &lt;- list(produce = data.frame(item = c(&#39;apples&#39;, &#39;bananas&#39;), price = c(3.99, 0.49)), condiments = data.frame(item = c(&#39;peanut_butter&#39;, &#39;mayonnaise&#39;), price = c(2.18, 3.89)), canned_goods = data.frame(item = c(&#39;black_beans&#39;, &#39;tomato_sauce&#39;), price = c(0.99, 0.69)), grains = data.frame(item = c(&#39;bread&#39;, &#39;pasta&#39;), price = c(2.99, 1.99)), dairy = data.frame(item = c(&#39;milk&#39;, &#39;butter&#39;), price = c(2.73, 2.57))) groc $produce item price 1 apples 3.99 2 bananas 0.49 $condiments item price 1 peanut_butter 2.18 2 mayonnaise 3.89 $canned_goods item price 1 black_beans 0.99 2 tomato_sauce 0.69 $grains item price 1 bread 2.99 2 pasta 1.99 $dairy item price 1 milk 2.73 2 butter 2.57 Here, we use lists and data frames to create a data set of our grocery list. This list can be traversed depending on what section of the store we find ourselves. For example, suppose we are in the produce section, and we need to recall what items to buy. We could utilize the following code to remind ourselves. groc$produce Is this grocery list an example of rectangular or non-rectangular data? Are there examples of rectangular data contained within the grocery list? How could we restructure the data to rectangularize the grocery list? As constructed, this grocery list is an example of non-rectangular data. As a whole, the grocery list is not shaped like a rectangule, but rather, consists of sets of rectangular data, where the sets are defined by the section of the store. Within a section of the store, the items and prices are given in rectangular form since every value is defined by a row and column. While non-rectangular data is often a useful return object for user-defined functions, they are often troublesome to work with. If a data set can be restructured or created in rectangular form, it should be. Rectangular data is especially important within the Tidyverse, a self-described ‘opinionated collection of R pacakges designed for data science’. All packages within the Tidyverse rely on the priciple of tidy data, data structures where observations are given by rows and variables are given by columns. As defined, tidy data are rectangular, so as we embark on wrangling, visualizing, and modeling data in future chapters, it is important to ponder the nature of our data and whether it can be rectangularized. Let’s consider how we can rectangularize the grocery list. Instead of creating a list of named data frames, where the name represents the section of the store, let’s create a grocery list where each row represents an item and columns specify the section and price. Because the Tidyverse requires rectangular data, there are several functions which are handy for converting data structures to rectangular form. We could utilize one of these functions to rectangularize the data set. library(tidyverse, quietly = TRUE) -- Attaching packages -------- v ggplot2 3.3.2 v purrr 0.3.4 v tibble 3.0.3 v dplyr 1.0.2 v tidyr 1.1.2 v stringr 1.4.0 v readr 1.3.1 v forcats 0.5.0 -- Conflicts ----------------- x lubridate::as.difftime() masks base::as.difftime() x lubridate::date() masks base::date() x dplyr::filter() masks stats::filter() x dplyr::group_rows() masks kableExtra::group_rows() x lubridate::intersect() masks base::intersect() x dplyr::lag() masks stats::lag() x lubridate::setdiff() masks base::setdiff() x lubridate::union() masks base::union() groc_rec &lt;- groc %&gt;% bind_rows(., .id = &#39;section&#39;) groc_rec Or, we can simply create the grocery list in rectangular form to begin with. Any feedback for this section? Click here 2.1.1 Reading and Writing Rectangular Data Rectangular data are often stored locally using text files (.txt), comma seperated value files (.csv), and Excel files (.xlsx). When data are written to these file types, they are easy to view across devices, without the need for R. Since most grocery store trips obviate the need for R, let’s consider how to write our grocery list to each of these file types. To write and read data to and from text files or comma seperated value files, the readr package will come in handy, whereas the xlsx package will allow us to write and read to and from Excel files. To write data from R to a file, we will leverage commands begining with write. # text file readr::write_delim(groc_rec, path = &#39;./data_raw/groceries-rectangular.txt&#39;) # csv file readr::write_csv(groc_rec, path = &#39;./data_raw/groceries-rectangular.csv&#39;) # Excel file xlsx::write.xlsx(groc_rec, file = &#39;./data_raw/groceries-rectangular.xlsx&#39;, row.names = FALSE) To read data from a file to R, we will leverage commands beginning with read. Before reading data into R, you will need to look at the file and file extension to better understand which function to use. # text file readr::read_delim(&#39;./data_raw/groceries-rectangular.txt&#39;, delim = &#39; &#39;) Parsed with column specification: cols( section = col_character(), item = col_character(), price = col_double() ) # csv file readr::read_csv(&#39;./data_raw/groceries-rectangular.csv&#39;) Parsed with column specification: cols( section = col_character(), item = col_character(), price = col_double() ) # Excel file xlsx::read.xlsx(&#39;./data_raw/groceries-rectangular.xlsx&#39;, sheetName = &#39;Sheet1&#39;) Reading files into R can sometimes be frustrating. Always look at the data to see if there are column headers and row names. Text files can have different delimiters, characters which seperate values in a data set. The default delimiter for readr::write_delim() is a space, but other common text delimiters are tabs, colons, semi-colons, or vertical bars. Commas are so commonly used as a delimiter, it gets a function of its own. Always ensure that data from an Excel spreadsheet are rectangular. Lastly, the readr package will guess the data type of each column. Check these data types are correct using str(). Any feedback for this section? Click here 2.1.2 Reading and Writing Non-rectangular Data Writing non-rectangular data from R to your local machine is easy with the help of write_rds() from the readr package. While the origin of ‘RDS’ is unclear, some believe it stands for R data serialization. Nonetheless, RDS files store single R objects, regardless of the structure. This means that RDS files are a great choice for data which cannot be written to rectangular file formats such as text, csv, and Excel files. The sister function entitled read_rds() allows you to read any RDS file directly into your current R environment, assuming the file already exists. Similar to RDS files, there are also RData files which can store multiple R objects. These files can be written from R to your local machine using save() and read from your local machine to R using load(). We recommend avoiding RData files, and instead, storing multiple R objects in one named list which is then saved as an RDS file. When there is inevitably non-rectangular data that exist which you would like to load into R, you are in for a treat. The rest of this module can loosely be viewed as a guide to managing and curating data. We will leverage many tools to tackle this problem, but in the next two sections, we will address two specifc, common instances of non-rectangular data: data from APIs and from scraped sources. Any feedback for this section? Click here "],
["apis-clean-and-curated.html", "2.2 APIs: Clean and Curated", " 2.2 APIs: Clean and Curated An application programming interface (API) is a set of functions and procedures which allows one computer program to interact with another. To simplify the concept remarkably, we will consider web-APIs where there is a server (computer waiting to provide data) and a client (computer making a request for data). The benefit of APIs is the result: clean and curated data from the host. The pre-processing needed to get the data in a workable form is entirely done on the server side. We, however, are responsible for making the request. Web-APIs often utilize JavaScript Object Notation (JSON), another example of non-rectangular data. We will utilize the httr and the jsonlite packages to retrieve the latest sports lines from Bovada, an online sportsbook. Before we start, we’ll need to download the httr and jsonlite packages and load them into our current environment. Furthermore, we will need to find the address of the server to which we will send the request. library(httr, quietly = TRUE) library(jsonlite, quietly = TRUE) Attaching package: &#39;jsonlite&#39; The following object is masked from &#39;package:purrr&#39;: flatten bov_nfl_api &lt;- &quot;https://www.bovada.lv/services/sports/event/v2/events/A/description/football/nfl&quot; To ask for data through a web-API, we will need to make a GET request with the httr package’s GET() function. After making the request, we can read about the server’s response. bov_req &lt;- httr::GET(url = bov_nfl_api) bov_req Response [https://www.bovada.lv/services/sports/event/v2/events/A/description/football/nfl] Date: 2020-09-16 20:57 Status: 200 Content-Type: application/json;charset=utf-8 Size: 1.13 MB If the request was successful, then the status of the request will read 200. Otherwise, there was some error with your request. For a list of HTTP status codes and their respective definitions, follow this link. Since the response clarifys that the content is indeed driven by JavaScript, then we will utilize the jsonlite package to read the JSON structured data. A handy function we will use will be fromJSON() which converts a character vector containing data in JSON structure to native structures in R like lists. So, in order, we will Extract the content from the server’s response Convert the content to a character vector, maintaining the JSON structure Restructure the data into native R structures, using fromJSON(). content &lt;- bov_req$content content_char &lt;- rawToChar(content) bov_res &lt;- jsonlite::fromJSON(content_char) Of course, we could also create a function which takes the server’s response and converts the content to native R structures. We will want to code in a force stop if the response status is not 200. We will also want to require the httr and jsonlite packages which will automatically install the packages if a user calls the function without having the packages installed. convert_JSON &lt;- function(resp){ # call needed packages require(httr) require(jsonlite) # stop if the server returned an error httr::stop_for_status(resp) # return JSON content in native R structures return(jsonlite::fromJSON(rawToChar(resp$content))) } Finally, we can get the same output by simply calling the function. identical(convert_JSON(bov_req), bov_res) [1] TRUE Some web-APIs require additional information from the us as outlined in the documentation for the API. In this case, the user would need to provide additional query parameters in their GET request. Thankfully, this functionality is ingrained in the httr package’s GET() function. For more information on how to include query parameters, type ??GET into your R console. Any feedback for this section? Click here "],
["scraping-messy-and-mangled.html", "2.3 Scraping: Messy and Mangled", " 2.3 Scraping: Messy and Mangled If you are reading this textbook, at some point in your career, you are likely to want or need data which exists on the web. You have looked for downloadable sources and Google searched for an API, but alas, no luck. The last resort for importing data into R is web scraping. Web scraping is a technique for harvesting data which is portrayed on the web and exists in hypertext markup language (HTML), the language of web browser documents. 2.3.1 Scraping vs API The benefit of using an API are clean data. For example, we can traverse the result to find the latest NFL events. head(bov_res[[2]][[1]][,2]) [1] &quot;Cincinnati Bengals @ Cleveland Browns&quot; [2] &quot;Atlanta Falcons @ Dallas Cowboys&quot; [3] &quot;Buffalo Bills @ Miami Dolphins&quot; [4] &quot;Carolina Panthers @ Tampa Bay Buccaneers&quot; [5] &quot;Denver Broncos @ Pittsburgh Steelers&quot; [6] &quot;Detroit Lions @ Green Bay Packers&quot; With more digging, we can find which teams are playing at home. head(bov_res[[2]][[1]][[16]]) [[1]] id name home 1 7410847-11904219 Cleveland Browns TRUE 2 7410847-11904217 Cincinnati Bengals FALSE [[2]] id name home 1 7410866-11904234 Dallas Cowboys TRUE 2 7410866-11904242 Atlanta Falcons FALSE [[3]] id name home 1 7410932-11904224 Miami Dolphins TRUE 2 7410932-11904215 Buffalo Bills FALSE [[4]] id name home 1 7410868-11904225 Tampa Bay Buccaneers TRUE 2 7410868-11904216 Carolina Panthers FALSE [[5]] id name home 1 7410927-11904223 Pittsburgh Steelers TRUE 2 7410927-11904245 Denver Broncos FALSE [[6]] id name home 1 7410940-11904228 Green Bay Packers TRUE 2 7410940-11904244 Detroit Lions FALSE We can also find the current line of each of these games. library(rlist, quietly = TRUE) bov_res[[2]][[1]][[17]] %&gt;% map(., ~.x[[&#39;markets&#39;]]) %&gt;% map(., ~pluck(.x, 1)) %&gt;% map(., ~.x[[&#39;outcomes&#39;]]) %&gt;% map(., ~pluck(.x, 1)) %&gt;% rlist::list.filter(., all(c(&#39;A&#39;, &#39;H&#39;) %in% type)) %&gt;% map(., ~bind_cols(.x, select(.x$price, -id))) %&gt;% map(., ~select(.x, description, handicap, american)) %&gt;% head() [[1]] description handicap american 1 Cincinnati Bengals 6.0 -115 2 Cleveland Browns -6.0 -105 [[2]] description handicap american 1 Atlanta Falcons 4.0 -105 2 Dallas Cowboys -4.0 -115 [[3]] description handicap american 1 Buffalo Bills -6.0 -105 2 Miami Dolphins 6.0 -115 [[4]] description handicap american 1 Carolina Panthers 9.0 -110 2 Tampa Bay Buccaneers -9.0 -110 [[5]] description handicap american 1 Denver Broncos 7.5 -110 2 Pittsburgh Steelers -7.5 -110 [[6]] description handicap american 1 Detroit Lions 6.5 -115 2 Green Bay Packers -6.5 -105 While traversing these sometimes complicated lists may seem intimidating, with practice, working with data from an API is like a walk in the park compared to scraping data directly from the web. 2.3.2 Hypertext Markup Language (HTML) and Selector Gadgets Web sites are written in hypertext markup language. All contents that are displayed on a web page are structured through HTML with the help of HTML elements. HTML elements consist of a tag and contents. The tag defines how the web browser should format and display the content. Aptly, the content is what should be displayed. For example, if we wished to format text as a paragraph within the web document, then we could use the paragraph tag, &lt;p&gt;, to indicate the beginning of a paragraph. After opening a tag, we then specify the content to display before closing the tag. A complete paragraph may read: &lt;p&gt; This is the paragraph you want to scrape. &lt;/p&gt; Attributes are optional parameters which provide additional information about the element in which the attribute is included. For example, within the paragraph tag, you can define a class which Any feedback for this section? Click here "]
]
